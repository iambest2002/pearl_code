{"version":3,"sources":["typed-function.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function (global, factory) {\r\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n  typeof define === 'function' && define.amd ? define(factory) :\r\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global[\"'typed'\"] = factory());\r\n})(this, (function () { \r\n\r\n  function ok() {\r\n    return true;\r\n  }\r\n  function notOk() {\r\n    return false;\r\n  }\r\n  function undef() {\r\n    return undefined;\r\n  }\r\n  const NOT_TYPED_FUNCTION = 'Argument is not a typed-function.';\r\n\r\n  /**\r\n   * @typedef {{\r\n   *   params: Param[],\r\n   *   fn: function,\r\n   *   test: function,\r\n   *   implementation: function\r\n   * }} Signature\r\n   *\r\n   * @typedef {{\r\n   *   types: Type[],\r\n   *   hasAny: boolean,\r\n   *   hasConversion: boolean,\r\n   *   restParam: boolean\r\n   * }} Param\r\n   *\r\n   * @typedef {{\r\n   *   name: string,\r\n   *   typeIndex: number,\r\n   *   test: function,\r\n   *   isAny: boolean,\r\n   *   conversion?: ConversionDef,\r\n   *   conversionIndex: number,\r\n   * }} Type\r\n   *\r\n   * @typedef {{\r\n   *   from: string,\r\n   *   to: string,\r\n   *   convert: function (*) : *\r\n   * }} ConversionDef\r\n   *\r\n   * @typedef {{\r\n   *   name: string,\r\n   *   test: function(*) : boolean,\r\n   *   isAny?: boolean\r\n   * }} TypeDef\r\n   */\r\n\r\n  /**\r\n   * @returns {() => function}\r\n   */\r\n  function create() {\r\n    // data type tests\r\n\r\n    /**\r\n     * Returns true if the argument is a non-null \"plain\" object\r\n     */\r\n    function isPlainObject(x) {\r\n      return typeof x === 'object' && x !== null && x.constructor === Object;\r\n    }\r\n    const _types = [{\r\n      name: 'number',\r\n      test: function (x) {\r\n        return typeof x === 'number';\r\n      }\r\n    }, {\r\n      name: 'string',\r\n      test: function (x) {\r\n        return typeof x === 'string';\r\n      }\r\n    }, {\r\n      name: 'boolean',\r\n      test: function (x) {\r\n        return typeof x === 'boolean';\r\n      }\r\n    }, {\r\n      name: 'Function',\r\n      test: function (x) {\r\n        return typeof x === 'function';\r\n      }\r\n    }, {\r\n      name: 'Array',\r\n      test: Array.isArray\r\n    }, {\r\n      name: 'Date',\r\n      test: function (x) {\r\n        return x instanceof Date;\r\n      }\r\n    }, {\r\n      name: 'RegExp',\r\n      test: function (x) {\r\n        return x instanceof RegExp;\r\n      }\r\n    }, {\r\n      name: 'Object',\r\n      test: isPlainObject\r\n    }, {\r\n      name: 'null',\r\n      test: function (x) {\r\n        return x === null;\r\n      }\r\n    }, {\r\n      name: 'undefined',\r\n      test: function (x) {\r\n        return x === undefined;\r\n      }\r\n    }];\r\n    const anyType = {\r\n      name: 'any',\r\n      test: ok,\r\n      isAny: true\r\n    };\r\n\r\n    // Data structures to track the types. As these are local variables in\r\n    // create(), each typed universe will get its own copy, but the variables\r\n    // will only be accessible through the (closures of the) functions supplied\r\n    // as properties of the typed object, not directly.\r\n    // These will be initialized in clear() below\r\n    let typeMap; // primary store of all types\r\n    let typeList; // Array of just type names, for the sake of ordering\r\n\r\n    // And similar data structures for the type conversions:\r\n    let nConversions = 0;\r\n    // the actual conversions are stored on a property of the destination types\r\n\r\n    // This is a temporary object, will be replaced with a function at the end\r\n    let typed = {\r\n      createCount: 0\r\n    };\r\n\r\n    /**\r\n     * Takes a type name and returns the corresponding official type object\r\n     * for that type.\r\n     *\r\n     * @param {string} typeName\r\n     * @returns {TypeDef} type\r\n     */\r\n    function findType(typeName) {\r\n      const type = typeMap.get(typeName);\r\n      if (type) {\r\n        return type;\r\n      }\r\n      // Remainder is error handling\r\n      let message = 'Unknown type \"' + typeName + '\"';\r\n      const name = typeName.toLowerCase();\r\n      let otherName;\r\n      for (otherName of typeList) {\r\n        if (otherName.toLowerCase() === name) {\r\n          message += '. Did you mean \"' + otherName + '\" ?';\r\n          break;\r\n        }\r\n      }\r\n      throw new TypeError(message);\r\n    }\r\n\r\n    /**\r\n     * Adds an array `types` of type definitions to this typed instance.\r\n     * Each type definition should be an object with properties:\r\n     * 'name' - a string giving the name of the type; 'test' - function\r\n     * returning a boolean that tests membership in the type; and optionally\r\n     * 'isAny' - true only for the 'any' type.\r\n     *\r\n     * The second optional argument, `before`, gives the name of a type that\r\n     * these types should be added before. The new types are added in the\r\n     * order specified.\r\n     * @param {TypeDef[]} types\r\n     * @param {string | boolean} [beforeSpec='any'] before\r\n     */\r\n    function addTypes(types) {\r\n      let beforeSpec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';\r\n      const beforeIndex = beforeSpec ? findType(beforeSpec).index : typeList.length;\r\n      const newTypes = [];\r\n      for (let i = 0; i < types.length; ++i) {\r\n        if (!types[i] || typeof types[i].name !== 'string' || typeof types[i].test !== 'function') {\r\n          throw new TypeError('Object with properties {name: string, test: function} expected');\r\n        }\r\n        const typeName = types[i].name;\r\n        if (typeMap.has(typeName)) {\r\n          throw new TypeError('Duplicate type name \"' + typeName + '\"');\r\n        }\r\n        newTypes.push(typeName);\r\n        typeMap.set(typeName, {\r\n          name: typeName,\r\n          test: types[i].test,\r\n          isAny: types[i].isAny,\r\n          index: beforeIndex + i,\r\n          conversionsTo: [] // Newly added type can't have any conversions to it\r\n        });\r\n      }\r\n      // update the typeList\r\n      const affectedTypes = typeList.slice(beforeIndex);\r\n      typeList = typeList.slice(0, beforeIndex).concat(newTypes).concat(affectedTypes);\r\n      // Fix the indices\r\n      for (let i = beforeIndex + newTypes.length; i < typeList.length; ++i) {\r\n        typeMap.get(typeList[i]).index = i;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Removes all types and conversions from this typed instance.\r\n     * May cause previously constructed typed-functions to throw\r\n     * strange errors when they are called with types that do not\r\n     * match any of their signatures.\r\n     */\r\n    function clear() {\r\n      typeMap = new Map();\r\n      typeList = [];\r\n      nConversions = 0;\r\n      addTypes([anyType], false);\r\n    }\r\n\r\n    // initialize the types to the default list\r\n    clear();\r\n    addTypes(_types);\r\n\r\n    /**\r\n     * Removes all conversions, leaving the types alone.\r\n     */\r\n    function clearConversions() {\r\n      let typeName;\r\n      for (typeName of typeList) {\r\n        typeMap.get(typeName).conversionsTo = [];\r\n      }\r\n      nConversions = 0;\r\n    }\r\n\r\n    /**\r\n     * Find the type names that match a value.\r\n     * @param {*} value\r\n     * @return {string[]} Array of names of types for which\r\n     *                  the type test matches the value.\r\n     */\r\n    function findTypeNames(value) {\r\n      const matches = typeList.filter(name => {\r\n        const type = typeMap.get(name);\r\n        return !type.isAny && type.test(value);\r\n      });\r\n      if (matches.length) {\r\n        return matches;\r\n      }\r\n      return ['any'];\r\n    }\r\n\r\n    /**\r\n     * Check if an entity is a typed function created by any instance\r\n     * @param {any} entity\r\n     * @returns {boolean}\r\n     */\r\n    function isTypedFunction(entity) {\r\n      return entity && typeof entity === 'function' && '_typedFunctionData' in entity;\r\n    }\r\n\r\n    /**\r\n     * Find a specific signature from a (composed) typed function, for example:\r\n     *\r\n     *   typed.findSignature(fn, ['number', 'string'])\r\n     *   typed.findSignature(fn, 'number, string')\r\n     *   typed.findSignature(fn, 'number,string', {exact: true})\r\n     *\r\n     * This function findSignature will by default return the best match to\r\n     * the given signature, possibly employing type conversions.\r\n     *\r\n     * The (optional) third argument is a plain object giving options\r\n     * controlling the signature search. Currently the only implemented\r\n     * option is `exact`: if specified as true (default is false), only\r\n     * exact matches will be returned (i.e. signatures for which `fn` was\r\n     * directly defined). Note that a (possibly different) type matching\r\n     * `any`, or one or more instances of TYPE matching `...TYPE` are\r\n     * considered exact matches in this regard, as no conversions are used.\r\n     *\r\n     * This function returns a \"signature\" object, as does `typed.resolve()`,\r\n     * which is a plain object with four keys: `params` (the array of parameters\r\n     * for this signature), `fn` (the originally supplied function for this\r\n     * signature), `test` (a generated function that determines if an argument\r\n     * list matches this signature, and `implementation` (the function to call\r\n     * on a matching argument list, that performs conversions if necessary and\r\n     * then calls the originally supplied function).\r\n     *\r\n     * @param {Function} fn                   A typed-function\r\n     * @param {string | string[]} signature\r\n     *     Signature to be found, can be an array or a comma separated string.\r\n     * @param {object} options  Controls the signature search as documented\r\n     * @return {{ params: Param[], fn: function, test: function, implementation: function }}\r\n     *     Returns the matching signature, or throws an error when no signature\r\n     *     is found.\r\n     */\r\n    function findSignature(fn, signature, options) {\r\n      if (!isTypedFunction(fn)) {\r\n        throw new TypeError(NOT_TYPED_FUNCTION);\r\n      }\r\n\r\n      // Canonicalize input\r\n      const exact = options && options.exact;\r\n      const stringSignature = Array.isArray(signature) ? signature.join(',') : signature;\r\n      const params = parseSignature(stringSignature);\r\n      const canonicalSignature = stringifyParams(params);\r\n\r\n      // First hope we get lucky and exactly match a signature\r\n      if (!exact || canonicalSignature in fn.signatures) {\r\n        // OK, we can check the internal signatures\r\n        const match = fn._typedFunctionData.signatureMap.get(canonicalSignature);\r\n        if (match) {\r\n          return match;\r\n        }\r\n      }\r\n\r\n      // Oh well, we did not; so we have to go back and check the parameters\r\n      // one by one, in order to catch things like `any` and rest params.\r\n      // Note here we can assume there is at least one parameter, because\r\n      // the empty signature would have matched successfully above.\r\n      const nParams = params.length;\r\n      let remainingSignatures;\r\n      if (exact) {\r\n        remainingSignatures = [];\r\n        let name;\r\n        for (name in fn.signatures) {\r\n          remainingSignatures.push(fn._typedFunctionData.signatureMap.get(name));\r\n        }\r\n      } else {\r\n        remainingSignatures = fn._typedFunctionData.signatures;\r\n      }\r\n      for (let i = 0; i < nParams; ++i) {\r\n        const want = params[i];\r\n        const filteredSignatures = [];\r\n        let possibility;\r\n        for (possibility of remainingSignatures) {\r\n          const have = getParamAtIndex(possibility.params, i);\r\n          if (!have || want.restParam && !have.restParam) {\r\n            continue;\r\n          }\r\n          if (!have.hasAny) {\r\n            // have to check all of the wanted types are available\r\n            const haveTypes = paramTypeSet(have);\r\n            if (want.types.some(wtype => !haveTypes.has(wtype.name))) {\r\n              continue;\r\n            }\r\n          }\r\n          // OK, this looks good\r\n          filteredSignatures.push(possibility);\r\n        }\r\n        remainingSignatures = filteredSignatures;\r\n        if (remainingSignatures.length === 0) break;\r\n      }\r\n      // Return the first remaining signature that was totally matched:\r\n      let candidate;\r\n      for (candidate of remainingSignatures) {\r\n        if (candidate.params.length <= nParams) {\r\n          return candidate;\r\n        }\r\n      }\r\n      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + stringifyParams(params, ', ') + '))');\r\n    }\r\n\r\n    /**\r\n     * Find the proper function to call for a specific signature from\r\n     * a (composed) typed function, for example:\r\n     *\r\n     *   typed.find(fn, ['number', 'string'])\r\n     *   typed.find(fn, 'number, string')\r\n     *   typed.find(fn, 'number,string', {exact: true})\r\n     *\r\n     * This function find will by default return the best match to\r\n     * the given signature, possibly employing type conversions (and returning\r\n     * a function that will perform those conversions as needed). The\r\n     * (optional) third argument is a plain object giving options contolling\r\n     * the signature search. Currently only the option `exact` is implemented,\r\n     * which defaults to \"false\". If `exact` is specified as true, then only\r\n     * exact matches will be returned (i.e. signatures for which `fn` was\r\n     * directly defined). Uses of `any` and `...TYPE` are considered exact if\r\n     * no conversions are necessary to apply the corresponding function.\r\n     *\r\n     * @param {Function} fn                   A typed-function\r\n     * @param {string | string[]} signature\r\n     *     Signature to be found, can be an array or a comma separated string.\r\n     * @param {object} options  Controls the signature match as documented\r\n     * @return {function}\r\n     *     Returns the function to call for the given signature, or throws an\r\n     *     error if no match is found.\r\n     */\r\n    function find(fn, signature, options) {\r\n      return findSignature(fn, signature, options).implementation;\r\n    }\r\n\r\n    /**\r\n     * Convert a given value to another data type, specified by type name.\r\n     *\r\n     * @param {*} value\r\n     * @param {string} typeName\r\n     */\r\n    function convert(value, typeName) {\r\n      // check conversion is needed\r\n      const type = findType(typeName);\r\n      if (type.test(value)) {\r\n        return value;\r\n      }\r\n      const conversions = type.conversionsTo;\r\n      if (conversions.length === 0) {\r\n        throw new Error('There are no conversions to ' + typeName + ' defined.');\r\n      }\r\n      for (let i = 0; i < conversions.length; i++) {\r\n        const fromType = findType(conversions[i].from);\r\n        if (fromType.test(value)) {\r\n          return conversions[i].convert(value);\r\n        }\r\n      }\r\n      throw new Error('Cannot convert ' + value + ' to ' + typeName);\r\n    }\r\n\r\n    /**\r\n     * Stringify parameters in a normalized way\r\n     * @param {Param[]} params\r\n     * @param {string} [','] separator\r\n     * @return {string}\r\n     */\r\n    function stringifyParams(params) {\r\n      let separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';\r\n      return params.map(p => p.name).join(separator);\r\n    }\r\n\r\n    /**\r\n     * Parse a parameter, like \"...number | boolean\"\r\n     * @param {string} param\r\n     * @return {Param} param\r\n     */\r\n    function parseParam(param) {\r\n      const restParam = param.indexOf('...') === 0;\r\n      const types = !restParam ? param : param.length > 3 ? param.slice(3) : 'any';\r\n      const typeDefs = types.split('|').map(s => findType(s.trim()));\r\n      let hasAny = false;\r\n      let paramName = restParam ? '...' : '';\r\n      const exactTypes = typeDefs.map(function (type) {\r\n        hasAny = type.isAny || hasAny;\r\n        paramName += type.name + '|';\r\n        return {\r\n          name: type.name,\r\n          typeIndex: type.index,\r\n          test: type.test,\r\n          isAny: type.isAny,\r\n          conversion: null,\r\n          conversionIndex: -1\r\n        };\r\n      });\r\n      return {\r\n        types: exactTypes,\r\n        name: paramName.slice(0, -1),\r\n        // remove trailing '|' from above\r\n        hasAny,\r\n        hasConversion: false,\r\n        restParam\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Expands a parsed parameter with the types available from currently\r\n     * defined conversions.\r\n     * @param {Param} param\r\n     * @return {Param} param\r\n     */\r\n    function expandParam(param) {\r\n      const typeNames = param.types.map(t => t.name);\r\n      const matchingConversions = availableConversions(typeNames);\r\n      let hasAny = param.hasAny;\r\n      let newName = param.name;\r\n      const convertibleTypes = matchingConversions.map(function (conversion) {\r\n        const type = findType(conversion.from);\r\n        hasAny = type.isAny || hasAny;\r\n        newName += '|' + conversion.from;\r\n        return {\r\n          name: conversion.from,\r\n          typeIndex: type.index,\r\n          test: type.test,\r\n          isAny: type.isAny,\r\n          conversion,\r\n          conversionIndex: conversion.index\r\n        };\r\n      });\r\n      return {\r\n        types: param.types.concat(convertibleTypes),\r\n        name: newName,\r\n        hasAny,\r\n        hasConversion: convertibleTypes.length > 0,\r\n        restParam: param.restParam\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Return the set of type names in a parameter.\r\n     * Caches the result for efficiency\r\n     *\r\n     * @param {Param} param\r\n     * @return {Set<string>} typenames\r\n     */\r\n    function paramTypeSet(param) {\r\n      if (!param.typeSet) {\r\n        param.typeSet = new Set();\r\n        param.types.forEach(type => param.typeSet.add(type.name));\r\n      }\r\n      return param.typeSet;\r\n    }\r\n\r\n    /**\r\n     * Parse a signature with comma separated parameters,\r\n     * like \"number | boolean, ...string\"\r\n     *\r\n     * @param {string} signature\r\n     * @return {Param[]} params\r\n     */\r\n    function parseSignature(rawSignature) {\r\n      const params = [];\r\n      if (typeof rawSignature !== 'string') {\r\n        throw new TypeError('Signatures must be strings');\r\n      }\r\n      const signature = rawSignature.trim();\r\n      if (signature === '') {\r\n        return params;\r\n      }\r\n      const rawParams = signature.split(',');\r\n      for (let i = 0; i < rawParams.length; ++i) {\r\n        const parsedParam = parseParam(rawParams[i].trim());\r\n        if (parsedParam.restParam && i !== rawParams.length - 1) {\r\n          throw new SyntaxError('Unexpected rest parameter \"' + rawParams[i] + '\": ' + 'only allowed for the last parameter');\r\n        }\r\n        // if invalid, short-circuit (all the types may have been filtered)\r\n        if (parsedParam.types.length === 0) {\r\n          return null;\r\n        }\r\n        params.push(parsedParam);\r\n      }\r\n      return params;\r\n    }\r\n\r\n    /**\r\n     * Test whether a set of params contains a restParam\r\n     * @param {Param[]} params\r\n     * @return {boolean} Returns true when the last parameter is a restParam\r\n     */\r\n    function hasRestParam(params) {\r\n      const param = last(params);\r\n      return param ? param.restParam : false;\r\n    }\r\n\r\n    /**\r\n     * Create a type test for a single parameter, which can have one or multiple\r\n     * types.\r\n     * @param {Param} param\r\n     * @return {function(x: *) : boolean} Returns a test function\r\n     */\r\n    function compileTest(param) {\r\n      if (!param || param.types.length === 0) {\r\n        // nothing to do\r\n        return ok;\r\n      } else if (param.types.length === 1) {\r\n        return findType(param.types[0].name).test;\r\n      } else if (param.types.length === 2) {\r\n        const test0 = findType(param.types[0].name).test;\r\n        const test1 = findType(param.types[1].name).test;\r\n        return function or(x) {\r\n          return test0(x) || test1(x);\r\n        };\r\n      } else {\r\n        // param.types.length > 2\r\n        const tests = param.types.map(function (type) {\r\n          return findType(type.name).test;\r\n        });\r\n        return function or(x) {\r\n          for (let i = 0; i < tests.length; i++) {\r\n            if (tests[i](x)) {\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        };\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Create a test for all parameters of a signature\r\n     * @param {Param[]} params\r\n     * @return {function(args: Array<*>) : boolean}\r\n     */\r\n    function compileTests(params) {\r\n      let tests, test0, test1;\r\n      if (hasRestParam(params)) {\r\n        // variable arguments like '...number'\r\n        tests = initial(params).map(compileTest);\r\n        const varIndex = tests.length;\r\n        const lastTest = compileTest(last(params));\r\n        const testRestParam = function (args) {\r\n          for (let i = varIndex; i < args.length; i++) {\r\n            if (!lastTest(args[i])) {\r\n              return false;\r\n            }\r\n          }\r\n          return true;\r\n        };\r\n        return function testArgs(args) {\r\n          for (let i = 0; i < tests.length; i++) {\r\n            if (!tests[i](args[i])) {\r\n              return false;\r\n            }\r\n          }\r\n          return testRestParam(args) && args.length >= varIndex + 1;\r\n        };\r\n      } else {\r\n        // no variable arguments\r\n        if (params.length === 0) {\r\n          return function testArgs(args) {\r\n            return args.length === 0;\r\n          };\r\n        } else if (params.length === 1) {\r\n          test0 = compileTest(params[0]);\r\n          return function testArgs(args) {\r\n            return test0(args[0]) && args.length === 1;\r\n          };\r\n        } else if (params.length === 2) {\r\n          test0 = compileTest(params[0]);\r\n          test1 = compileTest(params[1]);\r\n          return function testArgs(args) {\r\n            return test0(args[0]) && test1(args[1]) && args.length === 2;\r\n          };\r\n        } else {\r\n          // arguments.length > 2\r\n          tests = params.map(compileTest);\r\n          return function testArgs(args) {\r\n            for (let i = 0; i < tests.length; i++) {\r\n              if (!tests[i](args[i])) {\r\n                return false;\r\n              }\r\n            }\r\n            return args.length === tests.length;\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Find the parameter at a specific index of a Params list.\r\n     * Handles rest parameters.\r\n     * @param {Param[]} params\r\n     * @param {number} index\r\n     * @return {Param | null} Returns the matching parameter when found,\r\n     *                        null otherwise.\r\n     */\r\n    function getParamAtIndex(params, index) {\r\n      return index < params.length ? params[index] : hasRestParam(params) ? last(params) : null;\r\n    }\r\n\r\n    /**\r\n     * Get all type names of a parameter\r\n     * @param {Params[]} params\r\n     * @param {number} index\r\n     * @return {string[]} Returns an array with type names\r\n     */\r\n    function getTypeSetAtIndex(params, index) {\r\n      const param = getParamAtIndex(params, index);\r\n      if (!param) {\r\n        return new Set();\r\n      }\r\n      return paramTypeSet(param);\r\n    }\r\n\r\n    /**\r\n     * Test whether a type is an exact type or conversion\r\n     * @param {Type} type\r\n     * @return {boolean} Returns true when\r\n     */\r\n    function isExactType(type) {\r\n      return type.conversion === null || type.conversion === undefined;\r\n    }\r\n\r\n    /**\r\n     * Helper function for creating error messages: create an array with\r\n     * all available types on a specific argument index.\r\n     * @param {Signature[]} signatures\r\n     * @param {number} index\r\n     * @return {string[]} Returns an array with available types\r\n     */\r\n    function mergeExpectedParams(signatures, index) {\r\n      const typeSet = new Set();\r\n      signatures.forEach(signature => {\r\n        const paramSet = getTypeSetAtIndex(signature.params, index);\r\n        let name;\r\n        for (name of paramSet) {\r\n          typeSet.add(name);\r\n        }\r\n      });\r\n      return typeSet.has('any') ? ['any'] : Array.from(typeSet);\r\n    }\r\n\r\n    /**\r\n     * Create\r\n     * @param {string} name             The name of the function\r\n     * @param {array.<*>} args          The actual arguments passed to the function\r\n     * @param {Signature[]} signatures  A list with available signatures\r\n     * @return {TypeError} Returns a type error with additional data\r\n     *                     attached to it in the property `data`\r\n     */\r\n    function createError(name, args, signatures) {\r\n      let err, expected;\r\n      const _name = name || 'unnamed';\r\n\r\n      // test for wrong type at some index\r\n      let matchingSignatures = signatures;\r\n      let index;\r\n      for (index = 0; index < args.length; index++) {\r\n        const nextMatchingDefs = [];\r\n        matchingSignatures.forEach(signature => {\r\n          const param = getParamAtIndex(signature.params, index);\r\n          const test = compileTest(param);\r\n          if ((index < signature.params.length || hasRestParam(signature.params)) && test(args[index])) {\r\n            nextMatchingDefs.push(signature);\r\n          }\r\n        });\r\n        if (nextMatchingDefs.length === 0) {\r\n          // no matching signatures anymore, throw error \"wrong type\"\r\n          expected = mergeExpectedParams(matchingSignatures, index);\r\n          if (expected.length > 0) {\r\n            const actualTypes = findTypeNames(args[index]);\r\n            err = new TypeError('Unexpected type of argument in function ' + _name + ' (expected: ' + expected.join(' or ') + ', actual: ' + actualTypes.join(' | ') + ', index: ' + index + ')');\r\n            err.data = {\r\n              category: 'wrongType',\r\n              fn: _name,\r\n              index,\r\n              actual: actualTypes,\r\n              expected\r\n            };\r\n            return err;\r\n          }\r\n        } else {\r\n          matchingSignatures = nextMatchingDefs;\r\n        }\r\n      }\r\n\r\n      // test for too few arguments\r\n      const lengths = matchingSignatures.map(function (signature) {\r\n        return hasRestParam(signature.params) ? Infinity : signature.params.length;\r\n      });\r\n      if (args.length < Math.min.apply(null, lengths)) {\r\n        expected = mergeExpectedParams(matchingSignatures, index);\r\n        err = new TypeError('Too few arguments in function ' + _name + ' (expected: ' + expected.join(' or ') + ', index: ' + args.length + ')');\r\n        err.data = {\r\n          category: 'tooFewArgs',\r\n          fn: _name,\r\n          index: args.length,\r\n          expected\r\n        };\r\n        return err;\r\n      }\r\n\r\n      // test for too many arguments\r\n      const maxLength = Math.max.apply(null, lengths);\r\n      if (args.length > maxLength) {\r\n        err = new TypeError('Too many arguments in function ' + _name + ' (expected: ' + maxLength + ', actual: ' + args.length + ')');\r\n        err.data = {\r\n          category: 'tooManyArgs',\r\n          fn: _name,\r\n          index: args.length,\r\n          expectedLength: maxLength\r\n        };\r\n        return err;\r\n      }\r\n\r\n      // Generic error\r\n      const argTypes = [];\r\n      for (let i = 0; i < args.length; ++i) {\r\n        argTypes.push(findTypeNames(args[i]).join('|'));\r\n      }\r\n      err = new TypeError('Arguments of type \"' + argTypes.join(', ') + '\" do not match any of the defined signatures of function ' + _name + '.');\r\n      err.data = {\r\n        category: 'mismatch',\r\n        actual: argTypes\r\n      };\r\n      return err;\r\n    }\r\n\r\n    /**\r\n     * Find the lowest index of all exact types of a parameter (no conversions)\r\n     * @param {Param} param\r\n     * @return {number} Returns the index of the lowest type in typed.types\r\n     */\r\n    function getLowestTypeIndex(param) {\r\n      let min = typeList.length + 1;\r\n      for (let i = 0; i < param.types.length; i++) {\r\n        if (isExactType(param.types[i])) {\r\n          min = Math.min(min, param.types[i].typeIndex);\r\n        }\r\n      }\r\n      return min;\r\n    }\r\n\r\n    /**\r\n     * Find the lowest index of the conversion of all types of the parameter\r\n     * having a conversion\r\n     * @param {Param} param\r\n     * @return {number} Returns the lowest index of the conversions of this type\r\n     */\r\n    function getLowestConversionIndex(param) {\r\n      let min = nConversions + 1;\r\n      for (let i = 0; i < param.types.length; i++) {\r\n        if (!isExactType(param.types[i])) {\r\n          min = Math.min(min, param.types[i].conversionIndex);\r\n        }\r\n      }\r\n      return min;\r\n    }\r\n\r\n    /**\r\n     * Compare two params\r\n     * @param {Param} param1\r\n     * @param {Param} param2\r\n     * @return {number} returns -1 when param1 must get a lower\r\n     *                  index than param2, 1 when the opposite,\r\n     *                  or zero when both are equal\r\n     */\r\n    function compareParams(param1, param2) {\r\n      // We compare a number of metrics on a param in turn:\r\n      // 1) 'any' parameters are the least preferred\r\n      if (param1.hasAny) {\r\n        if (!param2.hasAny) {\r\n          return 1;\r\n        }\r\n      } else if (param2.hasAny) {\r\n        return -1;\r\n      }\r\n\r\n      // 2) Prefer non-rest to rest parameters\r\n      if (param1.restParam) {\r\n        if (!param2.restParam) {\r\n          return 1;\r\n        }\r\n      } else if (param2.restParam) {\r\n        return -1;\r\n      }\r\n\r\n      // 3) Prefer exact type match to conversions\r\n      if (param1.hasConversion) {\r\n        if (!param2.hasConversion) {\r\n          return 1;\r\n        }\r\n      } else if (param2.hasConversion) {\r\n        return -1;\r\n      }\r\n\r\n      // 4) Prefer lower type index:\r\n      const typeDiff = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);\r\n      if (typeDiff < 0) {\r\n        return -1;\r\n      }\r\n      if (typeDiff > 0) {\r\n        return 1;\r\n      }\r\n\r\n      // 5) Prefer lower conversion index\r\n      const convDiff = getLowestConversionIndex(param1) - getLowestConversionIndex(param2);\r\n      if (convDiff < 0) {\r\n        return -1;\r\n      }\r\n      if (convDiff > 0) {\r\n        return 1;\r\n      }\r\n\r\n      // Don't have a basis for preference\r\n      return 0;\r\n    }\r\n\r\n    /**\r\n     * Compare two signatures\r\n     * @param {Signature} signature1\r\n     * @param {Signature} signature2\r\n     * @return {number} returns a negative number when param1 must get a lower\r\n     *                  index than param2, a positive number when the opposite,\r\n     *                  or zero when both are equal\r\n     */\r\n    function compareSignatures(signature1, signature2) {\r\n      const pars1 = signature1.params;\r\n      const pars2 = signature2.params;\r\n      const last1 = last(pars1);\r\n      const last2 = last(pars2);\r\n      const hasRest1 = hasRestParam(pars1);\r\n      const hasRest2 = hasRestParam(pars2);\r\n      // We compare a number of metrics on signatures in turn:\r\n      // 1) An \"any rest param\" is least preferred\r\n      if (hasRest1 && last1.hasAny) {\r\n        if (!hasRest2 || !last2.hasAny) {\r\n          return 1;\r\n        }\r\n      } else if (hasRest2 && last2.hasAny) {\r\n        return -1;\r\n      }\r\n\r\n      // 2) Minimize the number of 'any' parameters\r\n      let any1 = 0;\r\n      let conv1 = 0;\r\n      let par;\r\n      for (par of pars1) {\r\n        if (par.hasAny) ++any1;\r\n        if (par.hasConversion) ++conv1;\r\n      }\r\n      let any2 = 0;\r\n      let conv2 = 0;\r\n      for (par of pars2) {\r\n        if (par.hasAny) ++any2;\r\n        if (par.hasConversion) ++conv2;\r\n      }\r\n      if (any1 !== any2) {\r\n        return any1 - any2;\r\n      }\r\n\r\n      // 3) A conversion rest param is less preferred\r\n      if (hasRest1 && last1.hasConversion) {\r\n        if (!hasRest2 || !last2.hasConversion) {\r\n          return 1;\r\n        }\r\n      } else if (hasRest2 && last2.hasConversion) {\r\n        return -1;\r\n      }\r\n\r\n      // 4) Minimize the number of conversions\r\n      if (conv1 !== conv2) {\r\n        return conv1 - conv2;\r\n      }\r\n\r\n      // 5) Prefer no rest param\r\n      if (hasRest1) {\r\n        if (!hasRest2) {\r\n          return 1;\r\n        }\r\n      } else if (hasRest2) {\r\n        return -1;\r\n      }\r\n\r\n      // 6) Prefer shorter with rest param, longer without\r\n      const lengthCriterion = (pars1.length - pars2.length) * (hasRest1 ? -1 : 1);\r\n      if (lengthCriterion !== 0) {\r\n        return lengthCriterion;\r\n      }\r\n\r\n      // Signatures are identical in each of the above metrics.\r\n      // In particular, they are the same length.\r\n      // We can therefore compare the parameters one by one.\r\n      // First we count which signature has more preferred parameters.\r\n      const comparisons = [];\r\n      let tc = 0;\r\n      for (let i = 0; i < pars1.length; ++i) {\r\n        const thisComparison = compareParams(pars1[i], pars2[i]);\r\n        comparisons.push(thisComparison);\r\n        tc += thisComparison;\r\n      }\r\n      if (tc !== 0) {\r\n        return tc;\r\n      }\r\n\r\n      // They have the same number of preferred parameters, so go by the\r\n      // earliest parameter in which we have a preference.\r\n      // In other words, dispatch is driven somewhat more by earlier\r\n      // parameters than later ones.\r\n      let c;\r\n      for (c of comparisons) {\r\n        if (c !== 0) {\r\n          return c;\r\n        }\r\n      }\r\n\r\n      // It's a tossup:\r\n      return 0;\r\n    }\r\n\r\n    /**\r\n     * Produce a list of all conversions from distinct types to one of\r\n     * the given types.\r\n     *\r\n     * @param {string[]} typeNames\r\n     * @return {ConversionDef[]} Returns the conversions that are available\r\n     *                        resulting in any given type (if any)\r\n     */\r\n    function availableConversions(typeNames) {\r\n      if (typeNames.length === 0) {\r\n        return [];\r\n      }\r\n      const types = typeNames.map(findType);\r\n      if (typeNames.length > 1) {\r\n        types.sort((t1, t2) => t1.index - t2.index);\r\n      }\r\n      let matches = types[0].conversionsTo;\r\n      if (typeNames.length === 1) {\r\n        return matches;\r\n      }\r\n      matches = matches.concat([]); // shallow copy the matches\r\n      // Since the types are now in index order, we just want the first\r\n      // occurrence of any from type:\r\n      const knownTypes = new Set(typeNames);\r\n      for (let i = 1; i < types.length; ++i) {\r\n        let newMatch;\r\n        for (newMatch of types[i].conversionsTo) {\r\n          if (!knownTypes.has(newMatch.from)) {\r\n            matches.push(newMatch);\r\n            knownTypes.add(newMatch.from);\r\n          }\r\n        }\r\n      }\r\n      return matches;\r\n    }\r\n\r\n    /**\r\n     * Preprocess arguments before calling the original function:\r\n     * - if needed convert the parameters\r\n     * - in case of rest parameters, move the rest parameters into an Array\r\n     * @param {Param[]} params\r\n     * @param {function} fn\r\n     * @return {function} Returns a wrapped function\r\n     */\r\n    function compileArgsPreprocessing(params, fn) {\r\n      let fnConvert = fn;\r\n\r\n      // TODO: can we make this wrapper function smarter/simpler?\r\n\r\n      if (params.some(p => p.hasConversion)) {\r\n        const restParam = hasRestParam(params);\r\n        const compiledConversions = params.map(compileArgConversion);\r\n        fnConvert = function convertArgs() {\r\n          const args = [];\r\n          const last = restParam ? arguments.length - 1 : arguments.length;\r\n          for (let i = 0; i < last; i++) {\r\n            args[i] = compiledConversions[i](arguments[i]);\r\n          }\r\n          if (restParam) {\r\n            args[last] = arguments[last].map(compiledConversions[last]);\r\n          }\r\n          return fn.apply(this, args);\r\n        };\r\n      }\r\n      let fnPreprocess = fnConvert;\r\n      if (hasRestParam(params)) {\r\n        const offset = params.length - 1;\r\n        fnPreprocess = function preprocessRestParams() {\r\n          return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));\r\n        };\r\n      }\r\n      return fnPreprocess;\r\n    }\r\n\r\n    /**\r\n     * Compile conversion for a parameter to the right type\r\n     * @param {Param} param\r\n     * @return {function} Returns the wrapped function that will convert arguments\r\n     *\r\n     */\r\n    function compileArgConversion(param) {\r\n      let test0, test1, conversion0, conversion1;\r\n      const tests = [];\r\n      const conversions = [];\r\n      param.types.forEach(function (type) {\r\n        if (type.conversion) {\r\n          tests.push(findType(type.conversion.from).test);\r\n          conversions.push(type.conversion.convert);\r\n        }\r\n      });\r\n\r\n      // create optimized conversion functions depending on the number of conversions\r\n      switch (conversions.length) {\r\n        case 0:\r\n          return function convertArg(arg) {\r\n            return arg;\r\n          };\r\n        case 1:\r\n          test0 = tests[0];\r\n          conversion0 = conversions[0];\r\n          return function convertArg(arg) {\r\n            if (test0(arg)) {\r\n              return conversion0(arg);\r\n            }\r\n            return arg;\r\n          };\r\n        case 2:\r\n          test0 = tests[0];\r\n          test1 = tests[1];\r\n          conversion0 = conversions[0];\r\n          conversion1 = conversions[1];\r\n          return function convertArg(arg) {\r\n            if (test0(arg)) {\r\n              return conversion0(arg);\r\n            }\r\n            if (test1(arg)) {\r\n              return conversion1(arg);\r\n            }\r\n            return arg;\r\n          };\r\n        default:\r\n          return function convertArg(arg) {\r\n            for (let i = 0; i < conversions.length; i++) {\r\n              if (tests[i](arg)) {\r\n                return conversions[i](arg);\r\n              }\r\n            }\r\n            return arg;\r\n          };\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Split params with union types in to separate params.\r\n     *\r\n     * For example:\r\n     *\r\n     *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\r\n     *     // returns:\r\n     *     // [\r\n     *     //   ['Array', 'string'],\r\n     *     //   ['Array', 'RegExp'],\r\n     *     //   ['Object', 'string'],\r\n     *     //   ['Object', 'RegExp']\r\n     *     // ]\r\n     *\r\n     * @param {Param[]} params\r\n     * @return {Param[]}\r\n     */\r\n    function splitParams(params) {\r\n      function _splitParams(params, index, paramsSoFar) {\r\n        if (index < params.length) {\r\n          const param = params[index];\r\n          let resultingParams = [];\r\n          if (param.restParam) {\r\n            // split the types of a rest parameter in two:\r\n            // one with only exact types, and one with exact types and conversions\r\n            const exactTypes = param.types.filter(isExactType);\r\n            if (exactTypes.length < param.types.length) {\r\n              resultingParams.push({\r\n                types: exactTypes,\r\n                name: '...' + exactTypes.map(t => t.name).join('|'),\r\n                hasAny: exactTypes.some(t => t.isAny),\r\n                hasConversion: false,\r\n                restParam: true\r\n              });\r\n            }\r\n            resultingParams.push(param);\r\n          } else {\r\n            // split all the types of a regular parameter into one type per param\r\n            resultingParams = param.types.map(function (type) {\r\n              return {\r\n                types: [type],\r\n                name: type.name,\r\n                hasAny: type.isAny,\r\n                hasConversion: type.conversion,\r\n                restParam: false\r\n              };\r\n            });\r\n          }\r\n\r\n          // recurse over the groups with types\r\n          return flatMap(resultingParams, function (nextParam) {\r\n            return _splitParams(params, index + 1, paramsSoFar.concat([nextParam]));\r\n          });\r\n        } else {\r\n          // we've reached the end of the parameters.\r\n          return [paramsSoFar];\r\n        }\r\n      }\r\n      return _splitParams(params, 0, []);\r\n    }\r\n\r\n    /**\r\n     * Test whether two param lists represent conflicting signatures\r\n     * @param {Param[]} params1\r\n     * @param {Param[]} params2\r\n     * @return {boolean} Returns true when the signatures conflict, false otherwise.\r\n     */\r\n    function conflicting(params1, params2) {\r\n      const ii = Math.max(params1.length, params2.length);\r\n      for (let i = 0; i < ii; i++) {\r\n        const typeSet1 = getTypeSetAtIndex(params1, i);\r\n        const typeSet2 = getTypeSetAtIndex(params2, i);\r\n        let overlap = false;\r\n        let name;\r\n        for (name of typeSet2) {\r\n          if (typeSet1.has(name)) {\r\n            overlap = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!overlap) {\r\n          return false;\r\n        }\r\n      }\r\n      const len1 = params1.length;\r\n      const len2 = params2.length;\r\n      const restParam1 = hasRestParam(params1);\r\n      const restParam2 = hasRestParam(params2);\r\n      return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;\r\n    }\r\n\r\n    /**\r\n     * Helper function for `resolveReferences` that returns a copy of\r\n     * functionList wihe any prior resolutions cleared out, in case we are\r\n     * recycling signatures from a prior typed function construction.\r\n     *\r\n     * @param {Array.<function|typed-reference>} functionList\r\n     * @return {Array.<function|typed-reference>}\r\n     */\r\n    function clearResolutions(functionList) {\r\n      return functionList.map(fn => {\r\n        if (isReferToSelf(fn)) {\r\n          return referToSelf(fn.referToSelf.callback);\r\n        }\r\n        if (isReferTo(fn)) {\r\n          return makeReferTo(fn.referTo.references, fn.referTo.callback);\r\n        }\r\n        return fn;\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Take a list of references, a list of functions functionList, and a\r\n     * signatureMap indexing signatures into functionList, and return\r\n     * the list of resolutions, or a false-y value if they don't all\r\n     * resolve in a valid way (yet).\r\n     *\r\n     * @param {string[]} references\r\n     * @param {Array<function|typed-reference} functionList\r\n     * @param {Object.<string, integer>} signatureMap\r\n     * @return {function[] | false} resolutions\r\n     */\r\n    function collectResolutions(references, functionList, signatureMap) {\r\n      const resolvedReferences = [];\r\n      let reference;\r\n      for (reference of references) {\r\n        let resolution = signatureMap[reference];\r\n        if (typeof resolution !== 'number') {\r\n          throw new TypeError('No definition for referenced signature \"' + reference + '\"');\r\n        }\r\n        resolution = functionList[resolution];\r\n        if (typeof resolution !== 'function') {\r\n          return false;\r\n        }\r\n        resolvedReferences.push(resolution);\r\n      }\r\n      return resolvedReferences;\r\n    }\r\n\r\n    /**\r\n     * Resolve any references in the functionList for the typed function\r\n     * itself. The signatureMap tells which index in the functionList a\r\n     * given signature should be mapped to (for use in resolving typed.referTo)\r\n     * and self provides the destions of a typed.referToSelf.\r\n     *\r\n     * @param {Array<function | typed-reference-object>} functionList\r\n     * @param {Object.<string, function>} signatureMap\r\n     * @param {function} self  The typed-function itself\r\n     * @return {Array<function>} The list of resolved functions\r\n     */\r\n    function resolveReferences(functionList, signatureMap, self) {\r\n      const resolvedFunctions = clearResolutions(functionList);\r\n      const isResolved = new Array(resolvedFunctions.length).fill(false);\r\n      let leftUnresolved = true;\r\n      while (leftUnresolved) {\r\n        leftUnresolved = false;\r\n        let nothingResolved = true;\r\n        for (let i = 0; i < resolvedFunctions.length; ++i) {\r\n          if (isResolved[i]) continue;\r\n          const fn = resolvedFunctions[i];\r\n          if (isReferToSelf(fn)) {\r\n            resolvedFunctions[i] = fn.referToSelf.callback(self);\r\n            // Preserve reference in case signature is reused someday:\r\n            resolvedFunctions[i].referToSelf = fn.referToSelf;\r\n            isResolved[i] = true;\r\n            nothingResolved = false;\r\n          } else if (isReferTo(fn)) {\r\n            const resolvedReferences = collectResolutions(fn.referTo.references, resolvedFunctions, signatureMap);\r\n            if (resolvedReferences) {\r\n              resolvedFunctions[i] = fn.referTo.callback.apply(this, resolvedReferences);\r\n              // Preserve reference in case signature is reused someday:\r\n              resolvedFunctions[i].referTo = fn.referTo;\r\n              isResolved[i] = true;\r\n              nothingResolved = false;\r\n            } else {\r\n              leftUnresolved = true;\r\n            }\r\n          }\r\n        }\r\n        if (nothingResolved && leftUnresolved) {\r\n          throw new SyntaxError('Circular reference detected in resolving typed.referTo');\r\n        }\r\n      }\r\n      return resolvedFunctions;\r\n    }\r\n\r\n    /**\r\n     * Validate whether any of the function bodies contains a self-reference\r\n     * usage like `this(...)` or `this.signatures`. This self-referencing is\r\n     * deprecated since typed-function v3. It has been replaced with\r\n     * the functions typed.referTo and typed.referToSelf.\r\n     * @param {Object.<string, function>} signaturesMap\r\n     */\r\n    function validateDeprecatedThis(signaturesMap) {\r\n      // TODO: remove this deprecation warning logic some day (it's introduced in v3)\r\n\r\n      // match occurrences like 'this(' and 'this.signatures'\r\n      const deprecatedThisRegex = /\\bthis(\\(|\\.signatures\\b)/;\r\n      Object.keys(signaturesMap).forEach(signature => {\r\n        const fn = signaturesMap[signature];\r\n        if (deprecatedThisRegex.test(fn.toString())) {\r\n          throw new SyntaxError('Using `this` to self-reference a function ' + 'is deprecated since typed-function@3. ' + 'Use typed.referTo and typed.referToSelf instead.');\r\n        }\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Create a typed function\r\n     * @param {String} name               The name for the typed function\r\n     * @param {Object.<string, function>} rawSignaturesMap\r\n     *                                    An object with one or\r\n     *                                    multiple signatures as key, and the\r\n     *                                    function corresponding to the\r\n     *                                    signature as value.\r\n     * @return {function}  Returns the created typed function.\r\n     */\r\n    function createTypedFunction(name, rawSignaturesMap) {\r\n      typed.createCount++;\r\n      if (Object.keys(rawSignaturesMap).length === 0) {\r\n        throw new SyntaxError('No signatures provided');\r\n      }\r\n      if (typed.warnAgainstDeprecatedThis) {\r\n        validateDeprecatedThis(rawSignaturesMap);\r\n      }\r\n\r\n      // Main processing loop for signatures\r\n      const parsedParams = [];\r\n      const originalFunctions = [];\r\n      const signaturesMap = {};\r\n      const preliminarySignatures = []; // may have duplicates from conversions\r\n      let signature;\r\n      for (signature in rawSignaturesMap) {\r\n        // A) Protect against polluted Object prototype:\r\n        if (!Object.prototype.hasOwnProperty.call(rawSignaturesMap, signature)) {\r\n          continue;\r\n        }\r\n        // B) Parse the signature\r\n        const params = parseSignature(signature);\r\n        if (!params) continue;\r\n        // C) Check for conflicts\r\n        parsedParams.forEach(function (pp) {\r\n          if (conflicting(pp, params)) {\r\n            throw new TypeError('Conflicting signatures \"' + stringifyParams(pp) + '\" and \"' + stringifyParams(params) + '\".');\r\n          }\r\n        });\r\n        parsedParams.push(params);\r\n        // D) Store the provided function and add conversions\r\n        const functionIndex = originalFunctions.length;\r\n        originalFunctions.push(rawSignaturesMap[signature]);\r\n        const conversionParams = params.map(expandParam);\r\n        // E) Split the signatures and collect them up\r\n        let sp;\r\n        for (sp of splitParams(conversionParams)) {\r\n          const spName = stringifyParams(sp);\r\n          preliminarySignatures.push({\r\n            params: sp,\r\n            name: spName,\r\n            fn: functionIndex\r\n          });\r\n          if (sp.every(p => !p.hasConversion)) {\r\n            signaturesMap[spName] = functionIndex;\r\n          }\r\n        }\r\n      }\r\n      preliminarySignatures.sort(compareSignatures);\r\n\r\n      // Note the forward reference to theTypedFn\r\n      const resolvedFunctions = resolveReferences(originalFunctions, signaturesMap, theTypedFn);\r\n\r\n      // Fill in the proper function for each signature\r\n      let s;\r\n      for (s in signaturesMap) {\r\n        if (Object.prototype.hasOwnProperty.call(signaturesMap, s)) {\r\n          signaturesMap[s] = resolvedFunctions[signaturesMap[s]];\r\n        }\r\n      }\r\n      const signatures = [];\r\n      const internalSignatureMap = new Map(); // benchmarks faster than object\r\n      for (s of preliminarySignatures) {\r\n        // Note it's only safe to eliminate duplicates like this\r\n        // _after_ the signature sorting step above; otherwise we might\r\n        // remove the wrong one.\r\n        if (!internalSignatureMap.has(s.name)) {\r\n          s.fn = resolvedFunctions[s.fn];\r\n          signatures.push(s);\r\n          internalSignatureMap.set(s.name, s);\r\n        }\r\n      }\r\n\r\n      // we create a highly optimized checks for the first couple of signatures with max 2 arguments\r\n      const ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);\r\n      const ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);\r\n      const ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);\r\n      const ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);\r\n      const ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);\r\n      const ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);\r\n      const allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;\r\n\r\n      // compile the tests\r\n      for (let i = 0; i < signatures.length; ++i) {\r\n        signatures[i].test = compileTests(signatures[i].params);\r\n      }\r\n      const test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;\r\n      const test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;\r\n      const test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;\r\n      const test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;\r\n      const test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;\r\n      const test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;\r\n      const test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;\r\n      const test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;\r\n      const test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;\r\n      const test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;\r\n      const test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;\r\n      const test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;\r\n\r\n      // compile the functions\r\n      for (let i = 0; i < signatures.length; ++i) {\r\n        signatures[i].implementation = compileArgsPreprocessing(signatures[i].params, signatures[i].fn);\r\n      }\r\n      const fn0 = ok0 ? signatures[0].implementation : undef;\r\n      const fn1 = ok1 ? signatures[1].implementation : undef;\r\n      const fn2 = ok2 ? signatures[2].implementation : undef;\r\n      const fn3 = ok3 ? signatures[3].implementation : undef;\r\n      const fn4 = ok4 ? signatures[4].implementation : undef;\r\n      const fn5 = ok5 ? signatures[5].implementation : undef;\r\n      const len0 = ok0 ? signatures[0].params.length : -1;\r\n      const len1 = ok1 ? signatures[1].params.length : -1;\r\n      const len2 = ok2 ? signatures[2].params.length : -1;\r\n      const len3 = ok3 ? signatures[3].params.length : -1;\r\n      const len4 = ok4 ? signatures[4].params.length : -1;\r\n      const len5 = ok5 ? signatures[5].params.length : -1;\r\n\r\n      // simple and generic, but also slow\r\n      const iStart = allOk ? 6 : 0;\r\n      const iEnd = signatures.length;\r\n      // de-reference ahead for execution speed:\r\n      const tests = signatures.map(s => s.test);\r\n      const fns = signatures.map(s => s.implementation);\r\n      const generic = function generic() {\r\n\r\n        for (let i = iStart; i < iEnd; i++) {\r\n          if (tests[i](arguments)) {\r\n            return fns[i].apply(this, arguments);\r\n          }\r\n        }\r\n        return typed.onMismatch(name, arguments, signatures);\r\n      };\r\n\r\n      // create the typed function\r\n      // fast, specialized version. Falls back to the slower, generic one if needed\r\n      function theTypedFn(arg0, arg1) {\r\n\r\n        if (arguments.length === len0 && test00(arg0) && test01(arg1)) {\r\n          return fn0.apply(this, arguments);\r\n        }\r\n        if (arguments.length === len1 && test10(arg0) && test11(arg1)) {\r\n          return fn1.apply(this, arguments);\r\n        }\r\n        if (arguments.length === len2 && test20(arg0) && test21(arg1)) {\r\n          return fn2.apply(this, arguments);\r\n        }\r\n        if (arguments.length === len3 && test30(arg0) && test31(arg1)) {\r\n          return fn3.apply(this, arguments);\r\n        }\r\n        if (arguments.length === len4 && test40(arg0) && test41(arg1)) {\r\n          return fn4.apply(this, arguments);\r\n        }\r\n        if (arguments.length === len5 && test50(arg0) && test51(arg1)) {\r\n          return fn5.apply(this, arguments);\r\n        }\r\n        return generic.apply(this, arguments);\r\n      }\r\n\r\n      // attach name the typed function\r\n      try {\r\n        Object.defineProperty(theTypedFn, 'name', {\r\n          value: name\r\n        });\r\n      } catch (err) {\r\n        // old browsers do not support Object.defineProperty and some don't support setting the name property\r\n        // the function name is not essential for the functioning, it's mostly useful for debugging,\r\n        // so it's fine to have unnamed functions.\r\n      }\r\n\r\n      // attach signatures to the function.\r\n      // This property is close to the original collection of signatures\r\n      // used to create the typed-function, just with unions split:\r\n      theTypedFn.signatures = signaturesMap;\r\n\r\n      // Store internal data for functions like resolve, find, etc.\r\n      // Also serves as the flag that this is a typed-function\r\n      theTypedFn._typedFunctionData = {\r\n        signatures,\r\n        signatureMap: internalSignatureMap\r\n      };\r\n      return theTypedFn;\r\n    }\r\n\r\n    /**\r\n     * Action to take on mismatch\r\n     * @param {string} name      Name of function that was attempted to be called\r\n     * @param {Array} args       Actual arguments to the call\r\n     * @param {Array} signatures Known signatures of the named typed-function\r\n     */\r\n    function _onMismatch(name, args, signatures) {\r\n      throw createError(name, args, signatures);\r\n    }\r\n\r\n    /**\r\n     * Return all but the last items of an array or function Arguments\r\n     * @param {Array | Arguments} arr\r\n     * @return {Array}\r\n     */\r\n    function initial(arr) {\r\n      return slice(arr, 0, arr.length - 1);\r\n    }\r\n\r\n    /**\r\n     * return the last item of an array or function Arguments\r\n     * @param {Array | Arguments} arr\r\n     * @return {*}\r\n     */\r\n    function last(arr) {\r\n      return arr[arr.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Slice an array or function Arguments\r\n     * @param {Array | Arguments | IArguments} arr\r\n     * @param {number} start\r\n     * @param {number} [end]\r\n     * @return {Array}\r\n     */\r\n    function slice(arr, start, end) {\r\n      return Array.prototype.slice.call(arr, start, end);\r\n    }\r\n\r\n    /**\r\n     * Return the first item from an array for which test(arr[i]) returns true\r\n     * @param {Array} arr\r\n     * @param {function} test\r\n     * @return {* | undefined} Returns the first matching item\r\n     *                         or undefined when there is no match\r\n     */\r\n    function findInArray(arr, test) {\r\n      for (let i = 0; i < arr.length; i++) {\r\n        if (test(arr[i])) {\r\n          return arr[i];\r\n        }\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    /**\r\n     * Flat map the result invoking a callback for every item in an array.\r\n     * https://gist.github.com/samgiles/762ee337dff48623e729\r\n     * @param {Array} arr\r\n     * @param {function} callback\r\n     * @return {Array}\r\n     */\r\n    function flatMap(arr, callback) {\r\n      return Array.prototype.concat.apply([], arr.map(callback));\r\n    }\r\n\r\n    /**\r\n     * Create a reference callback to one or multiple signatures\r\n     *\r\n     * Syntax:\r\n     *\r\n     *     typed.referTo(signature1, signature2, ..., function callback(fn1, fn2, ...) {\r\n     *       // ...\r\n     *     })\r\n     *\r\n     * @returns {{referTo: {references: string[], callback}}}\r\n     */\r\n    function referTo() {\r\n      const references = initial(arguments).map(s => stringifyParams(parseSignature(s)));\r\n      const callback = last(arguments);\r\n      if (typeof callback !== 'function') {\r\n        throw new TypeError('Callback function expected as last argument');\r\n      }\r\n      return makeReferTo(references, callback);\r\n    }\r\n    function makeReferTo(references, callback) {\r\n      return {\r\n        referTo: {\r\n          references,\r\n          callback\r\n        }\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Create a reference callback to the typed-function itself\r\n     *\r\n     * @param {(self: function) => function} callback\r\n     * @returns {{referToSelf: { callback: function }}}\r\n     */\r\n    function referToSelf(callback) {\r\n      if (typeof callback !== 'function') {\r\n        throw new TypeError('Callback function expected as first argument');\r\n      }\r\n      return {\r\n        referToSelf: {\r\n          callback\r\n        }\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Test whether something is a referTo object, holding a list with reference\r\n     * signatures and a callback.\r\n     *\r\n     * @param {Object | function} objectOrFn\r\n     * @returns {boolean}\r\n     */\r\n    function isReferTo(objectOrFn) {\r\n      return objectOrFn && typeof objectOrFn.referTo === 'object' && Array.isArray(objectOrFn.referTo.references) && typeof objectOrFn.referTo.callback === 'function';\r\n    }\r\n\r\n    /**\r\n     * Test whether something is a referToSelf object, holding a callback where\r\n     * to pass `self`.\r\n     *\r\n     * @param {Object | function} objectOrFn\r\n     * @returns {boolean}\r\n     */\r\n    function isReferToSelf(objectOrFn) {\r\n      return objectOrFn && typeof objectOrFn.referToSelf === 'object' && typeof objectOrFn.referToSelf.callback === 'function';\r\n    }\r\n\r\n    /**\r\n     * Check if name is (A) new, (B) a match, or (C) a mismatch; and throw\r\n     * an error in case (C).\r\n     *\r\n     * @param { string | undefined } nameSoFar\r\n     * @param { string | undefined } newName\r\n     * @returns { string } updated name\r\n     */\r\n    function checkName(nameSoFar, newName) {\r\n      if (!nameSoFar) {\r\n        return newName;\r\n      }\r\n      if (newName && newName !== nameSoFar) {\r\n        const err = new Error('Function names do not match (expected: ' + nameSoFar + ', actual: ' + newName + ')');\r\n        err.data = {\r\n          actual: newName,\r\n          expected: nameSoFar\r\n        };\r\n        throw err;\r\n      }\r\n      return nameSoFar;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the implied name from an object with signature keys\r\n     * and function values, checking whether all value names match\r\n     *\r\n     * @param { {string: function} } obj\r\n     */\r\n    function getObjectName(obj) {\r\n      let name;\r\n      for (const key in obj) {\r\n        // Only pay attention to own properties, and only if their values\r\n        // are typed functions or functions with a signature property\r\n        if (Object.prototype.hasOwnProperty.call(obj, key) && (isTypedFunction(obj[key]) || typeof obj[key].signature === 'string')) {\r\n          name = checkName(name, obj[key].name);\r\n        }\r\n      }\r\n      return name;\r\n    }\r\n\r\n    /**\r\n     * Copy all of the signatures from the second argument into the first,\r\n     * which is modified by side effect, checking for conflicts\r\n     *\r\n     * @param {Object.<string, function|typed-reference>} dest\r\n     * @param {Object.<string, function|typed-reference>} source\r\n     */\r\n    function mergeSignatures(dest, source) {\r\n      let key;\r\n      for (key in source) {\r\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n          if (key in dest) {\r\n            if (source[key] !== dest[key]) {\r\n              const err = new Error('Signature \"' + key + '\" is defined twice');\r\n              err.data = {\r\n                signature: key,\r\n                sourceFunction: source[key],\r\n                destFunction: dest[key]\r\n              };\r\n              throw err;\r\n            }\r\n            // else: both signatures point to the same function, that's fine\r\n          }\r\n          dest[key] = source[key];\r\n        }\r\n      }\r\n    }\r\n    const saveTyped = typed;\r\n\r\n    /**\r\n     * Originally the main function was a typed function itself, but then\r\n     * it might not be able to generate error messages if the client\r\n     * replaced the type system with different names.\r\n     *\r\n     * Main entry: typed([name], functions/objects with signatures...)\r\n     *\r\n     * Assembles and returns a new typed-function from the given items\r\n     * that provide signatures and implementations, each of which may be\r\n     * * a plain object mapping (string) signatures to implementing functions,\r\n     * * a previously constructed typed function, or\r\n     * * any other single function with a string-valued property `signature`.\r\n      * The name of the resulting typed-function will be given by the\r\n     * string-valued name argument if present, or if not, by the name\r\n     * of any of the arguments that have one, as long as any that do are\r\n     * consistent with each other. If no name is specified, the name will be\r\n     * an empty string.\r\n     *\r\n     * @param {string} maybeName [optional]\r\n     * @param {(function|object)[]} signature providers\r\n     * @returns {typed-function}\r\n     */\r\n    typed = function (maybeName) {\r\n      const named = typeof maybeName === 'string';\r\n      const start = named ? 1 : 0;\r\n      let name = named ? maybeName : '';\r\n      const allSignatures = {};\r\n      for (let i = start; i < arguments.length; ++i) {\r\n        const item = arguments[i];\r\n        let theseSignatures = {};\r\n        let thisName;\r\n        if (typeof item === 'function') {\r\n          thisName = item.name;\r\n          if (typeof item.signature === 'string') {\r\n            // Case 1: Ordinary function with a string 'signature' property\r\n            theseSignatures[item.signature] = item;\r\n          } else if (isTypedFunction(item)) {\r\n            // Case 2: Existing typed function\r\n            theseSignatures = item.signatures;\r\n          }\r\n        } else if (isPlainObject(item)) {\r\n          // Case 3: Plain object, assume keys = signatures, values = functions\r\n          theseSignatures = item;\r\n          if (!named) {\r\n            thisName = getObjectName(item);\r\n          }\r\n        }\r\n        if (Object.keys(theseSignatures).length === 0) {\r\n          const err = new TypeError('Argument to \\'typed\\' at index ' + i + ' is not a (typed) function, ' + 'nor an object with signatures as keys and functions as values.');\r\n          err.data = {\r\n            index: i,\r\n            argument: item\r\n          };\r\n          throw err;\r\n        }\r\n        if (!named) {\r\n          name = checkName(name, thisName);\r\n        }\r\n        mergeSignatures(allSignatures, theseSignatures);\r\n      }\r\n      return createTypedFunction(name || '', allSignatures);\r\n    };\r\n    typed.create = create;\r\n    typed.createCount = saveTyped.createCount;\r\n    typed.onMismatch = _onMismatch;\r\n    typed.throwMismatchError = _onMismatch;\r\n    typed.createError = createError;\r\n    typed.clear = clear;\r\n    typed.clearConversions = clearConversions;\r\n    typed.addTypes = addTypes;\r\n    typed._findType = findType; // For unit testing only\r\n    typed.referTo = referTo;\r\n    typed.referToSelf = referToSelf;\r\n    typed.convert = convert;\r\n    typed.findSignature = findSignature;\r\n    typed.find = find;\r\n    typed.isTypedFunction = isTypedFunction;\r\n    typed.warnAgainstDeprecatedThis = true;\r\n\r\n    /**\r\n     * add a type (convenience wrapper for typed.addTypes)\r\n     * @param {{name: string, test: function}} type\r\n     * @param {boolean} [beforeObjectTest=true]\r\n     *                          If true, the new test will be inserted before\r\n     *                          the test with name 'Object' (if any), since\r\n     *                          tests for Object match Array and classes too.\r\n     */\r\n    typed.addType = function (type, beforeObjectTest) {\r\n      let before = 'any';\r\n      if (beforeObjectTest !== false && typeMap.has('Object')) {\r\n        before = 'Object';\r\n      }\r\n      typed.addTypes([type], before);\r\n    };\r\n\r\n    /**\r\n     * Verify that the ConversionDef conversion has a valid format.\r\n     *\r\n     * @param {conversionDef} conversion\r\n     * @return {void}\r\n     * @throws {TypeError|SyntaxError}\r\n     */\r\n    function _validateConversion(conversion) {\r\n      if (!conversion || typeof conversion.from !== 'string' || typeof conversion.to !== 'string' || typeof conversion.convert !== 'function') {\r\n        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');\r\n      }\r\n      if (conversion.to === conversion.from) {\r\n        throw new SyntaxError('Illegal to define conversion from \"' + conversion.from + '\" to itself.');\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Add a conversion\r\n     *\r\n     * @param {ConversionDef} conversion\r\n     * @param {{override: boolean}} [options]\r\n     * @returns {void}\r\n     * @throws {TypeError}\r\n     */\r\n    typed.addConversion = function (conversion) {\r\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\r\n        override: false\r\n      };\r\n      _validateConversion(conversion);\r\n      const to = findType(conversion.to);\r\n      const existing = to.conversionsTo.find(other => other.from === conversion.from);\r\n      if (existing) {\r\n        if (options && options.override) {\r\n          typed.removeConversion({\r\n            from: existing.from,\r\n            to: conversion.to,\r\n            convert: existing.convert\r\n          });\r\n        } else {\r\n          throw new Error('There is already a conversion from \"' + conversion.from + '\" to \"' + to.name + '\"');\r\n        }\r\n      }\r\n      to.conversionsTo.push({\r\n        from: conversion.from,\r\n        convert: conversion.convert,\r\n        index: nConversions++\r\n      });\r\n    };\r\n\r\n    /**\r\n     * Convenience wrapper to call addConversion on each conversion in a list.\r\n     *\r\n     * @param {ConversionDef[]} conversions\r\n     * @param {{override: boolean}} [options]\r\n     * @returns {void}\r\n     * @throws {TypeError}\r\n     */\r\n    typed.addConversions = function (conversions, options) {\r\n      conversions.forEach(conversion => typed.addConversion(conversion, options));\r\n    };\r\n\r\n    /**\r\n     * Remove the specified conversion. The format is the same as for\r\n     * addConversion, and the convert function must match or an error\r\n     * is thrown.\r\n     *\r\n     * @param {{from: string, to: string, convert: function}} conversion\r\n     * @returns {void}\r\n     * @throws {TypeError|SyntaxError|Error}\r\n     */\r\n    typed.removeConversion = function (conversion) {\r\n      _validateConversion(conversion);\r\n      const to = findType(conversion.to);\r\n      const existingConversion = findInArray(to.conversionsTo, c => c.from === conversion.from);\r\n      if (!existingConversion) {\r\n        throw new Error('Attempt to remove nonexistent conversion from ' + conversion.from + ' to ' + conversion.to);\r\n      }\r\n      if (existingConversion.convert !== conversion.convert) {\r\n        throw new Error('Conversion to remove does not match existing conversion');\r\n      }\r\n      const index = to.conversionsTo.indexOf(existingConversion);\r\n      to.conversionsTo.splice(index, 1);\r\n    };\r\n\r\n    /**\r\n     * Produce the specific signature that a typed function\r\n     * will execute on the given arguments. Here, a \"signature\" is an\r\n     * object with properties 'params', 'test', 'fn', and 'implementation'.\r\n     * This last property is a function that converts params as necessary\r\n     * and then calls 'fn'. Returns null if there is no matching signature.\r\n     * @param {typed-function} tf\r\n     * @param {any[]} argList\r\n     * @returns {{params: string, test: function, fn: function, implementation: function}}\r\n     */\r\n    typed.resolve = function (tf, argList) {\r\n      if (!isTypedFunction(tf)) {\r\n        throw new TypeError(NOT_TYPED_FUNCTION);\r\n      }\r\n      const sigs = tf._typedFunctionData.signatures;\r\n      for (let i = 0; i < sigs.length; ++i) {\r\n        if (sigs[i].test(argList)) {\r\n          return sigs[i];\r\n        }\r\n      }\r\n      return null;\r\n    };\r\n    return typed;\r\n  }\r\n  var typedFunction = create();\r\n\r\n  return typedFunction;\r\n\r\n}));\r\n//# sourceMappingURL=typed-function.js.map\r\n"]}